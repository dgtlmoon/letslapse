#!/usr/bin/python3
import io

import logging
import socketserver
from threading import Condition
from http import server
import threading, os, signal
import subprocess
from subprocess import check_call, call
import sys
from urllib.parse import urlparse, parse_qs
import argparse



PORT = 80

# Instantiate the parser
parser = argparse.ArgumentParser(description='Optional app description')

parser.add_argument('--testing', type=str,
                    help='Local development testing')
                    
args = parser.parse_args()
localDev = False
if args.testing == "True":
    localDev = True


if localDev:
    print("Running in testing mode for localhost development")
    siteRoot = "/home/steven/Documents/dev/pitime"
else: 
    import picamera
    siteRoot = "/home/pi/pitime"
    

os.chdir(siteRoot+"/")


#ipath = "/home/pi/Documents/mouse.py"    #CHANGE PATH TO LOCATION OF mouse.py

#def thread_second():
#    call(["python3", ipath])

def check_kill_process(pstring):
    for line in os.popen("ps ax | grep " + pstring + " | grep -v grep"):
        fields = line.split()
        pid = fields[0]
        os.kill(int(pid), signal.SIGKILL)

def liveFeed() :
    print("START liveFeed()")
    sysCommand = "python3 live.py "+str(hostIP)
    print(sysCommand)
    system(sysCommand)
    return "END liveFeed()"

def startTimelapse() :
    print("start startTimelapse")
    system('./go.sh')

    print("end startTimelapse")
    return "cool"

def shootPreview(ss, iso, awbg) :
    print("start shootPreview")
    sysCommand = "python3 preview.py --ss "+ss+" --iso "+iso+" --awbg "+awbg
    print(sysCommand)
    system(sysCommand)
    print("end shootPreview")
    return "end"


class StreamingOutput(object):
    def __init__(self):
        self.frame = None
        self.buffer = io.BytesIO()
        self.condition = Condition()

    def write(self, buf):
        if buf.startswith(b'\xff\xd8'):
            self.buffer.truncate()
            with self.condition:
                self.frame = self.buffer.getvalue()
                self.condition.notify_all()
            self.buffer.seek(0)
        return self.buffer.write(buf)

class StreamingHandler(server.BaseHTTPRequestHandler):
    def do_GET(self):
        print(urlparse(self.path))
        query_components = parse_qs(urlparse(self.path).query)
        if 'action' in query_components:
            # Sending an '200 OK' response
            self.send_response(200)
            # Setting the header
            self.send_header("Content-type", "application/json")
            actionVal = query_components["action"][0]

            # Some custom HTML code, possibly generated by another function
            jsonResp = f"Requested Action: {actionVal}"

            if actionVal == "live" :
                liveFeed()
            if actionVal == "start" :
                startTimelapse()
            if actionVal == "preview" :
                ss = query_components["ss"][0]
                iso = query_components["iso"][0]
                awbg = query_components["awbg"][0]
                shootPreview(ss, iso, awbg)
                print("cool preview")
            print(actionVal)
             # Whenever using 'send_header', you also have to call 'end_headers'
            self.end_headers()
            # Writing the HTML contents with UTF-8
            self.wfile.write(bytes(jsonResp, "utf8"))
            return
        elif self.path == '/':
            self.send_response(301)
            self.send_header('Location', '/index.html')
            self.end_headers()

        elif self.path == '/stream.mjpg':
            self.send_response(200)
            self.send_header('Age', 0)
            self.send_header('Cache-Control', 'no-cache, private')
            self.send_header('Pragma', 'no-cache')
            self.send_header('Content-Type', 'multipart/x-mixed-replace; boundary=FRAME')
            self.end_headers()
            try:
                while True:
                    with output.condition:
                        output.condition.wait()
                        frame = output.frame
                    self.wfile.write(b'--FRAME\r\n')
                    self.send_header('Content-Type', 'image/jpeg')
                    self.send_header('Content-Length', len(frame))
                    self.end_headers()
                    self.wfile.write(frame)
                    print("streaming now")
                    self.wfile.write(b'\r\n')
            except Exception as e:
                logging.warning(
                    'Removed streaming client %s: %s',
                    self.client_address, str(e))
        
        else :
            self.send_response(200)
            if self.path.endswith('.svg'):
                self.send_header('Content-Type', 'image/svg+xml')
            if self.path.endswith('.css'):
                self.send_header('Content-Type', 'text/css')
            if self.path.endswith('.js'):
                self.send_header('Content-Type', 'application/javascript')
            if self.path.endswith('.jpg'):
                self.send_header('Content-Type', 'image/jpeg')
            else:
                self.send_header('Content-Type', 'text/html')
            self.end_headers()
            with open(siteRoot+self.path, 'rb') as file: 
                self.wfile.write(file.read())
            
            #self.send_response(200)
            #self.send_header('Content-Type', 'text/html')
            #return http.server.SimpleHTTPRequestHandler.do_GET(self)

        #self.send_error(404)
        #self.end_headers()



class StreamingServer(socketserver.ThreadingMixIn, server.HTTPServer):
    allow_reuse_address = True
    daemon_threads = True
if localDev:
    print("basic webserver for local testing")
    handler = server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", PORT), handler) as httpd:
        print("Server started at localhost:" + str(PORT))
        httpd.serve_forever()
else: 
    with picamera.PiCamera(resolution='640x480', framerate=10) as camera:
        output = StreamingOutput()
        camera.start_recording(output, format='mjpeg')
        try:
            address = ('', PORT)
            server = StreamingServer(address, StreamingHandler)
            print("Streaming.")
            server.serve_forever()

        finally:
            print("ERROR: Stream not able to run. Stream ended.")
            camera.stop_recording()

    # print in the command line instead of file's console
    if __name__ == '__main__':
        main()
